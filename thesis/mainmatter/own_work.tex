\chapter{Semantic Description of Road Systems}
\label{ch:descriptionOfRoadSystems}
The following chapter provides a thorough description of the models and semantic description generation process for an urban aria from ESRI CityEngine (CE) using data provided by OpenStreetMap (OSM). Moreover, we provide a detailed explanation of the resulting JSON format which holds information about essential scene data. Lastly, we explain how the resulting file is parsed and used by Unity3D. Additionally, we defend design decisions, as well as describe failed attempts in the process.

A general overview of the whole process can be seen in Figure \ref{fig:overview}. Firstly, OSM data of a given area is sanitised and imported in CE. The same sanitised data is provided to SUMO, which generates additional road details which are not present in CE. Afterwards, 3D models are generated together with the combined from CE and SUMO semantic road description. In the end, they are imported and utilised in Unity3D. The navigation module which can be seen in \emph{Unity Game Engine} will be discussed in Chapter \ref{ch:gps}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.95\linewidth]{figures/overview}
	\caption{Overview of the scene creation workflow.}
	\label{fig:overview}
\end{figure}

\section{OSM Export}
As already introduced, the whole map data used in the MMK Driving Simulator is exported from OSM. In Figure \ref{fig:overview} we can see that exported \emph{OSM} file is fed to a \emph{OSM Sanitizer}. There are multiple reasons why this is necessary. Firstly, the objects contained in the export include some unnecessary information which are not present in the simulation, \emph{e.g.} underground network, footpaths. Moreover, this additional objects in the map represent a obstacle for both SUMO and CE when they are building a scene. For example, in Figure \ref{fig:nosimply} and \ref{fig:simply} one could see the difference in the shape creation between respectively a unsanitised and sanitised version of the same \emph{OSM} export data.  

\begin{figure}[htb]
	\centering
	\subfigure[Unsanitised] {
	  \includegraphics[width=0.4\textwidth]{figures/no-simply}
	  \label{fig:nosimply}
	}\hspace{0.05\textwidth}% \hfill or \hspace{5mm} or \hspace{0.3\textwidth}
	\subfigure[Sanitised] {
	  \includegraphics[width=0.4\textwidth]{figures/simply}
	  \label{fig:simply}
	}
	\caption{Comparison of the same CityEngine generated shapes from unsanitised and sanitised \emph{OSM} export file.}
\end{figure}

Since the information in the OSM export is only 2D, CE attempts to to find the perfect location for every shape, although most of them overlap. Therefore, it chooses \texttt{y} values which would generate reasonable shapes. Clearly, the scene generated in this way could not be used in Unity, so we have to delete some of the data. This was achieved by a Python3 script which can be found in \texttt{cityengine-mmk/scripts/osmsanitizer.py}. The script accepts only one input parameter, which is the OSM export file and produces a sanitised version of the same export with the appendix \texttt{-sanitized} in its name. The script can be executed in the console as follows assuming we are in the same folder as the script: \texttt{python3 osmsanitizer.py ../data/map.osm}. The result \texttt{map-sanitized.osm} will be again situated in \texttt{cityengine-mmk/data} folder. 

The sanitisation process follows a straightforward whitelisting fashion. Firstly, we have to delete all roads which are not drivable by a vehicle. Additionally, we want to preserve information about buildings and parkings which should be also present in the export. As we know from Chapter \ref{ch:background}, there are two main objects in OSM which hold information about the infrastructure of the road network: \texttt{way} and \texttt{relation}. According to the OSM documentation\footnote{\url{http://wiki.openstreetmap.org/wiki/Key:highway}}, all streets (\texttt{way} objects) must have a \texttt{highway} tag which marks its type. The valid highway tags are \texttt{motorway}, \texttt{motorway\_link}, \texttt{trunk}, \texttt{trunk\_link}, \texttt{primary}, \texttt{primary\_link}, \texttt{secondary}, \texttt{secondary\_link}, \texttt{tertiary}, \texttt{tertiary\_link}, \texttt{unclassified}, \texttt{residential}, \texttt{living\_street}, \texttt{unsurfaced}. If a \texttt{way} object does not contain a \texttt{highway} tag or the type of the road is not one of the aforementioned fourteen values, then it is deleted. Similarly, we check whether a \texttt{way} object contains a \texttt{building} tag which is set to \texttt{yes} and a \texttt{amenity} tag set to \texttt{parking}. This approach leaves in the OSM export buildings and parkings which coordinates and properties can be later imported in CE.

The sanitiser tries to solve another problem with OSM data, too. Sometimes information about streets, \emph{e.g.} maximum allowed speed or number of lanes, could be missing. When this is the case CE and SUMO try to extrapolate this information and suggest some valid values in order to create the resulting 3D models. Unfortunately, it could happen that both softwares provide different values for the same segment. Because we want to integrate the information streams coming from both, CE and SUMO to create a semantic description of the road network, this data extrapolation has to accomplished one step ahead in the sanitisation process. Therefore, we provide default valid values for missing information and add it to the OSM objects in the final sanitised file.

Finally, we have an OSM data which is valid and contains only the necessary information to build 3D shapes from it. Note that we do not delete any \texttt{node} objects because unused nodes, \emph{i.e.} not connected by a way or a relationship, are by default discarded in both, CE and SUMO.

\section{Semantic Description}
After we have accomplished the sanitisation of the OSM data, we can feed the resulting file to both CityEngine and SUMO as can be seen in Figure \ref{fig:overview}. Overall, we use the CE's Python interface to traverse all necessary objects and extract their properties. Afterwards, using the OSM ID, we extract lane information about the road network generated by SUMO, which is not available in CE. In the end, the combined information from CE and SUMO is exported as JSON format, which structure is described in Section \ref{sec:format}. 

\subsection{OSM Data Import Process}
In order to build a 3D urban scene accompanied by a semantic description of the road system, the user has to execute the steps which will be described in this section. Some of the steps were not able to be automated because of limitations related to CE. After starting a CE instance and opened the \texttt{cityengine-mmk} project which contains some essential rules to generate the 3D models, the user have to create a new empty scene. The sanitised OSM file has to be in \texttt{cityengine-mmk$\backslash$data} folder. Now the user can drag the file to the 3D viewport and a similar window as in Figure \ref{fig:import} will show up. Since we have removed all of the unnecessary object from the OSM file, we have just select all properties to be imported. Next, we can leave the \emph{Map OSM tags} selected, because we will need them later in the export process. Although our sanitiser has prepared the data, we still need \emph{Run Graph Cleanup Tool after Import} option because sometimes OSM data can be still imprecise. This option will delete unnecessary nodes and segments which overlap each other or are incomplete. Finally, we want CE to generate shapes for the road network, therefore we mark the \emph{Create Street/Intersection Shapes from Graph} option, too. There is a way to import an OSM map data directly using the CE's Python interface using \texttt{CE.importFile} and \texttt{OSMImportSettings}. Unfortunately, there is no way to select which of the each object's attributes to be imported. Moreover, only some of the attributes are selected by default which is not sufficient for our purposes. In the end, one have to select \emph{Finish} and the software will import the data and generate 3D shapes. An example import of the \emph{TU Viertel} in M\"unchen\footnote{\url{https://www.openstreetmap.org/#map=16/48.1493/11.5678}} can be seen in Figure \ref{fig:ce-1}.

\begin{figure}[htb]
	\centering
	\subfigure[] {
	  \includegraphics[width=0.28\textwidth]{figures/import}
	  \label{fig:import}
	}%\hspace{0.05\textwidth}% \hfill or \hspace{5mm} or \hspace{0.3\textwidth}
	\subfigure[] {
	  \includegraphics[width=0.68\textwidth]{figures/ce-1}
	  \label{fig:ce-1}
	}
	\caption{Example import dialog of OSM data in CE (a) and the resulting scene (b).}
\end{figure}

\subsection{CE Settings and Way-Segment Inconsistencies}
If we happen to leave the \emph{Run Simplify Graph Tool after Import} option marked, it may alter the imported OSM information, thus making it useless for cross referencing data between OSM and CE. The simplifying strategy of CE tries to merge some neighbouring segments in order to make the underlying road system more straight. Unfortunately, the CE's algorithm tries to merge properties of segments which are not meant to be combined. If it happens that the two segments, which are going to be combined, posses different OSM ID values, then the new segment receives the arithmetic mean of the two values. Of course, this new ID is not value and we cannot restore the original segments' IDs which renders it ineffective. To face this problem, we selected separately segments which have the same OSM IDs and called the simplifying tool only for them. Fortunately, this solved the problem with the destroyed IDs, nonetheless it broke junction's connections. In that case, two ways which were crossing in the middle forming a junction, were separated by CE in 4 segments, one for each exit of the junction. Calling the simplifying tool separately for the two pairs deleted the junction and placed one of the roads above the other. Clearly, this was not a solution to this problem, so we decided to unmark this tool since all of the generated shapes until this moment were acceptable.  

Another setting which could alter the shape generation process in a negative way and therefore decrease the reality of the produced scene is \emph{Run Generate Bridges Tool after Import}. This tool determines whether a segment's \texttt{y} value can be changed so it is lifted above another, underlying structure. This approach introduces some inaccuracies in the generated road models. Since this tool is absent from SUMO (it is only a 2D simulation) and we have to keep the shapes of the two generated urban networks as close as possible, we chose to switch off this option. However, this also means that the user have to furthermore adjust the shapes of some objects to represent the reality while staying coherent to SUMO.

Our first approach to create a semantic description of the road network in CE generated using OSM data involves completely ignoring the imported parameters in CE. We still have to export the vertices related to the CE's shapes using the CE's Python interface but all of the information about a given street segment such as number of lanes or speed limits will be directly taken from the OSM export file. The biggest advantage of this approach is that we can accomplish the \texttt{xml}-parsing in Python 3 which might be more performant than using the Jython interface in CE to read all of the attributes. Although this is generally true, we would break the export functionality in two big modules which are highly coherent and belong in one place. Moreover, there was another obstacle which seemed crucial for the success of this approach. CE does place almost (actually this causes yet another problem which will be discussed later in this section) every OSM node on its correct place and uses its original OSM ID, but this is not the case with segments. According to the shape of a given way (which is determined by its nodes), CE decides in how many actual segments to partition it. In other words, it may happen that one \texttt{way} object has more than one corresponding segments in the CE scene. Unfortunately, this introduces unnecessary difficulties in reconstructing a way from its segments which would be later crucial for the lane generation. Therefore, this first approach was abandoned in favour of a script purely implemented in the CE's Jython environment which depends on the imported attributes in CE from OSM to reconstruct each object's behaviour. 

\subsection{CE Export}
After importing the OSM data in CE as previously explained, the user have to assign rules to every object (\emph{e.g.} buildings, streets) and generate the 3D models. Some minor adjustments, such as moving buildings or placing crossing marks manually may be necessary in order to fully prepare the scene for export. Next, we can start the exporting process which is conducted by the \texttt{MMKExporter} class which can be seen in Figure \ref{fig:ce-overview-uml}. Firstly, we only consider the \texttt{MMKCEGraph}. 

The \texttt{MMKExporter} traverses all \texttt{nodes}, \texttt{segments} and \texttt{shapes} and parses them together with their attributes in the corresponding \texttt{CEGraphItem} objects (Figure \ref{fig:ce-uml}). Utilising the CE's Python interface (\texttt{ce.getAttribute(item, 'NameOFAttribute')}), it is easy to access all of the essential attributes of each object which were imported from OSM. As you can see in the UML class diagram in Figure \ref{fig:ce-uml}, we have adopted a simple inheritance structure which allows extendability, \emph{i.e.} adding more CE objects to export. As already explained in Chapter \ref{ch:background}, the whole scene has to be exported in the end to some compatible format. Moreover, one have to specify the \texttt{x}, \texttt{y}, and \texttt{z} offsets which will translate all object's coordinates to the origin. We always leave the \texttt{y} to \texttt{0} since data is interpolated anyways by CE. However, \texttt{x} and \texttt{z} has to be provided as input parameters to \texttt{MMKExporter} as \texttt{ox} and \texttt{oz}. This is necessary, since the parsed object's coordinates has to be also translated in order to stay coherent with the corresponding 3D models. Finally, \texttt{exportJson} method can be invoked after the parsing project has finished and the semantical description is exported in the \texttt{export} folder of the CE project in JSON format.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.65\textwidth]{figures/ce-overview-uml}
	\label{fig:ce-overview-uml}
	\caption{UML class diagram of \texttt{MMKExporter}, \texttt{MMKCEGraph}, and  \texttt{MMKSUMOGraph}}
\end{figure}

\subsection{Additional Information from SUMO}

Now, that we have the basic properties of the road network we can try to extend it with additional data by benefiting from OSM ID information. For instance, we can add lane information to every street segment. Unfortunately, OSM data holds only the number of lanes for each street segment, therefore, CE does not create any lane shapes. We could try to generate lane shapes by interpolating the given data: number of lanes per segment and shape of the segment. However, we know that MMK Driving Simulator uses SUMO to simulate other traffic in the scene, which defines its own lane information. Therefore, we can try to synchronise CE and SUMO shapes coordinates and adopt SUMO lanes in our CE Export. This approach was associated with numerous problems which will be discussed in the following.

Firstly, we parsed SUMO objects in corresponding \texttt{MMKGraphItem} objects from the \texttt{net.xml} file (Figure \ref{fig:ce-uml}). As introduced in Chapter \ref{ch:background}, the imported OSM data in SUMO is projected and translated using some parameters similarly to CE centring export feature. CE and SUMO use the same default projection settings but this is not the case with the translation offsets. Firstly, it was unknown to us that the \texttt{net.xml} contained a \texttt{location} which specifies exactly the translation offsets used to move all coordinates. Therefore, in order to find the lane's coordinates generated by SUMO in CE's coordinate system, we had to find some correlation between the objects. We know that OSM \texttt{way} objects are sometimes separated in more than one segments in CE. The same is valid for SUMO, so we could not use segments to calculate the necessary translation since more than one segment in CE have the same OSM ID. Then, we decided to take under consideration the nodes which are uniquely identifiable by their OSM ID values in both SUMO and CE. Overall, we searched for a the same node in CE and SUMO objects and calculated the difference in their coordinates. These values were then used to translate all SUMO object's coordinates. Moreover, we discovered that SUMO coordinates are rotated by \texttt{180$^{\circ}$} in comparison to CE coordinate system which had to be reversed before translation. This process was accelerated when we started using the offset values defined in \texttt{net.xml}'s node \texttt{location}.\\ 

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/ce-uml}
	\label{fig:ce-uml}
	\caption{UML class diagram showing the \texttt{MMKGraphItem} hierarchy and other classes used by the \texttt{MMKExporter}.}
\end{figure}

Nonetheless, this was not the only incompatibility between the coordinates of CE and SUMO objects. Apparently, there algorithms which CE and SUMO employ to generate junctions' shapes posses very different features. In Figure \ref{fig:simply} and Figure \ref{fig:sumo-incon-1} we can see the same junction created by CE and SUMO. Moreover, Figure \ref{fig:sumo-incon-2} shows lanes's figures generated by SUMO next to their corresponding CE models. Clearly, SUMO tries to centre the streets joining in a junction according to their number of lanes. Since, we cannot interfere in the junction creation algorithm in SUMO, we tried to shift the street models in CE to be alined to SUMO's shapes. This is done in \texttt{prepareScene} method in \texttt{MMKExporter} by exploiting the CE's segments' \texttt{/ce/street/streetOffset} attribute. Firstly, we search for segments which are joining in a junction, then we subtract the number of forward and backward lanes. This value is then used to shift the current segment either left or right according to its orientation in the whole road network. As already mentioned, OSM \texttt{way} objectss can be split into more than one segments in CE and SUMO. Therefore it could happen that the number of corresponding edges in SUMO and segments in CE is not the same. Thus, it could happen that one SUMO edge is represented in CE by two adjacent segments (from which one is at the junction). Therefore, we have to propagate our shifting algorithm in all directions away from the junction for similar segments, \emph{i.e.} same number and kind of lanes, as well as hierarchy. As a result, we have achieved a cohesion between CE's and SUMO's shape generation process. However, there might be some cases which could not be handled because of the versatile nature of both softwares the user has to resolve inconsistencies by herself.\\

\begin{figure}[htb]
	\centering
	\subfigure[] {
	  \includegraphics[width=0.4\textwidth]{figures/sumo-incon-1}
	  \label{fig:sumo-incon-1}
	}%\hspace{0.05\textwidth} \hfill or \hspace{5mm} or \hspace{0.3\textwidth}
	\subfigure[] {
	  \includegraphics[width=0.5\textwidth]{figures/sumo-incon-2}
	  \label{fig:sumo-incon-2}
	}
	\caption{Inconsistency between SUMO and CE junction creation.}
\end{figure}

Finally, we can start ordering the parsed lanes to their corresponding segments which is only possible because they share the same OSM ID values. However, this process can stumble upon yet another difference between SUMO's and CE's import process. Even after disabling all shape optimisation routines in CE, it might happen that some nodes are not imported but rather their corresponding segments are attached to another, neighbouring node. We can handle that by looking for nodes which are present in SUMO but missing in CE. Then, we find the nearest existing node in CE and attach to it the lane's information. However, this operation could be ambiguous because there could be more than one neighbouring nodes, so again the user has to fix inconsistencies. 

In conclusion, we have managed to integrate SUMO generated road information into CE urban network. As a result, we can export this combined semantic road description data as a whole. In the next section we throughly describe the JSON export format which holds these data.

\section{Format Description}
\label{sec:format}
As already introduced, we adopt a JSON format to hold the contents of the semantic description of a road network. In the following we discuss its advantages and disadvantages, as well as present all essential key value pairs used in the format.

In the beginning of this project, there was an idea to export the street network in OpenDRIVE format which was mentioned in the Chapter \ref{ch:background} in connection to other related work. Although OpenDRIVE allows a precise description of a road network and moreover, it is open-source and can be freely adopted, we withdraw from using it because of synchronisation reasons. More precisely, the data saved in OSM format has to be interpolated\cite{shi2011automatic}, which would introduce once again another desynchronisation between the network built by CE and the SUMO simulation. If this happens, the interpolated lanes in a hypothetical OpenDRIVE format would not coincide with the lane information generated by SUMO. Therefore, SUMO may not be able to be integrated as a simulation environment. Additionally, a JSON format, which we have chosen, has proven to be more human readable and easier to parse. Moreover, there exist a Unity module (Chapter \ref{ch:background}) which allows easier parsing. A JSON-based format gives us the opportunity to simultaneously provide a thorough description of a certain road network but also adopt and combine other data without breaking their coexistence. 

In Listing \ref{lis:format-1} one can see a general overview of the used JSON format. Firstly, we define the \texttt{author}, \texttt{date} of the export and the name of the \texttt{project}. These can be also changed in the script to arbitrary values. The more crucial parts of the export are \texttt{nodes} and \texttt{segments}. Obviously, each of these arrays hold all of the nodes, respectively segments in the CE scene. Previously, in the Research project by Max Mauerer, next to these values, there were also the number of all elements. We have chosen to eliminate these values since every parsing process can count the elements in each array. Next, the JSON export contains the \texttt{offsets} of CE and SUMO which was applied to each vertex coordinates in order to compose one coherent scene. Then, we have the \texttt{connections} array which holds the information about all possible connections between lanes. This helps us to build a navigation system in next chapter. Lastly, \texttt{sceneObjects} hold vertex information about other other objects in the scene which have no direct connection to the road network, \emph{e.g.} buildings, parkings.\\

    \begin{scriptsize}
	   \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the used JSON format for description of road networks.},label={lis:format-1}]
{
    "author": "TUM - MMK",
    "connections": [(*@$\dots$@*)],
    "date": "2017-11-13",
    "lanes": [(*@$\dots$@*)],
    "nodes": [(*@$\dots$@*)],
    "offsets": {(*@$\dots$@*)},
    "project": "cityengine-mmk",
    "sceneObjects": {(*@$\dots$@*)},
    "segments": [(*@$\dots$@*)]
}
	   \end{lstlisting}
    \end{scriptsize}

A sample \texttt{node} value can be seen in Listing \ref{lis:format-node}. Firstly, we define its hierarchy which is defined by SUMO and can be one of these values: \emph{unknown}, \emph{priority} or \emph{traffic\_light} depending on the kind of node. Secondly, each node holds information about every lane which is part of it. Next, we find two id values in the export: \emph{id} is the \texttt{OID} value generated by CE and \emph{osm} is obviously its OSM ID. Each node's neighbouring segments are also referenced in the export by their id values. A node can have zero or more shapes which properties can be found in the \texttt{shapes} array. Additionally, each shape has again two kind of id values (identical to the node's ids). Finally, the coordinates of each node are kept in the \texttt{vertices} key.\\
 	
    \begin{scriptsize}
        \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the node key in the JSON exportformat.},label={lis:format-node}]
(*@$\dots$@*)
"nodes": [
    {
        "hierarchy": "priority",
        "id": "40170885-31eb-11b2-8d80-00e8564141ba",
        "lanes": [
            ":21457467_0_0",
            (*@$\dots$@*)
        ],
        "neighbourSegments": [
            "46535ea4-31eb-11b2-8d80-00e8564141ba",
            (*@$\dots$@*)
        ],
        "osm": 21457467,
        "shapes": [
            {
                    "id": "40170885-31eb-11b2-8d80-00e8564141ba:0",
                    "osm": 21457467,
                    "vertices": [
                        {
                            "x": 227.979736328125,
                            "y": -0.0,
                            "z": 109.73065185546875
                        },(*@$\dots$@*)
                    ]
            }
        ],
        "vertices": [
                {
                    "x": 232.09375,
                    "y": -0.0,
                    "z": 106.30369567871094
                }
            ]
        }
        (*@$\dots$@*)
]
(*@$\dots$@*)
	   \end{lstlisting}
    \end{scriptsize}
    
Similarly to a node, each segment has two id values (OID and OSM ID) as well as analogous \texttt{shapes} key. The \texttt{hierarchy} key provides the type of road defined by OSM and each possible value has been described in Chapter \ref{ch:background}. Next, segments define in their \texttt{lanes} key the direction of each lane (\texttt{forward} or \texttt{backward}). There are some self-explanatory attributes which are specific to segments such as \texttt{maxspeed}, \texttt{oneway}, \texttt{length}. Additionally, each segment holds a reference to its \texttt{start} and \texttt{end} node. Lastly, there is a \texttt{vertices} array holding a list of 3D polygon points which describe the overall shape of the segment.\\

\begin{scriptsize}
        \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the segments key in the JSON export format.},label={lis:format-lanes}]
(*@$\dots$@*)
"segments": [
    {
        "end": "4545af7a-31eb-11b2-8d80-00e8564141ba",
        "hierarchy": "tertiary",
        "id": "4545fc94-31eb-11b2-8d80-00e8564141ba",
        "lanes": {
            "backward": [
                "-392069506#0_0"
            ],
            "forward": [
                "392069506#0_0"
            ]
        },
        "length": 27.097801453973258,
        "maxspeed": "50",
        "oneway": false,
        "osm": 392069506,
        "shapes": [(*@$\dots$@*)],
        "start": "43422a00-31eb-11b2-8d80-00e8564141ba",
        "vertices": [(*@$\dots$@*)]
    }
]           
(*@$\dots$@*)
	   \end{lstlisting}
    \end{scriptsize}

Lanes objects are straightforward to describe. They posses an \texttt{id} field where their SUMO generated id is saved. Additionally, they have an index, length and a list of vertices describing their shape.\\
 
\begin{scriptsize}
        \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the lanes key in the JSON export format.},label={lis:format-node}]
(*@$\dots$@*)
"lanes": [
        {
            "id": ":315667013_8_0",
            "index": "0",
            "length": "7.88",
            "vertices": [
                {
                    "x": 34.27750000000003,
                    "y": 0.0,
                    "z": -110.02389160156247
                },(*@$\dots$@*)
            ]
        }
    ]
(*@$\dots$@*)
	   \end{lstlisting}
    \end{scriptsize}
    
Next, we take under consideration the connections objects. The only information they hold is that there is a connection between two lanes (\texttt{fromLane} to \texttt{toLane}). Since, two lanes might be connected through intermediate links, these links are noted in the \texttt{via} array.\\
    
    \begin{scriptsize}
        \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the connection key in the JSON export format.},label={lis:format-node}]
(*@$\dots$@*)
"connections": [
        {
            "fromLane": "-155040996_0",
            "id": 0,
            "toLane": "392103894#1_0",
            "via": [
                ":4972221472_0_0"
            ]
        }, (*@$\dots$@*)
    ]
(*@$\dots$@*)
	   \end{lstlisting}
    \end{scriptsize}
    
The scene objects are defined as shapes and have all of their properties as described above. Finally, we consider the \texttt{offsets} key which gives the translation parameters applied to every object from CE and SUMO in order to have the same coordinate system. \\

    \begin{scriptsize}
        \begin{lstlisting}[language=json,firstnumber=1,caption={General overview of the offsets key in the JSON export format.},label={lis:format-node}]
(*@$\dots$@*)
"offsets": {
        "ce": {
            "x": -690985,
            "z": 5336220
        },
        "sumo": {
            "x": 605.7575,
            "z": 595.5761083984376
        }
    },
(*@$\dots$@*)
	   \end{lstlisting}
    \end{scriptsize}
    
To summarise, the resulting export file with all of its features described in this section holds all of the necessary information about a given urban network. In the next section we discuss how it is imported in Unity.

\section{Unity Import}


\begin{figure}[htb]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/unity-uml}
	\label{fig:unity-uml}
	\caption{}
\end{figure}

\chapter{Routing}
\label{ch:gps}

There are many applications of the semantic road description which can be used to improve the usability of the MMK Driving Simulator. One such application is navigation which we will discuss in this chapter. In Figure \ref{fig:nav} one can see a vehicle (above, right) which wants to reach the blue point (down, right). Utilising the connectivity of the lanes derived by SUMO, as explained in previous chapter, we can calculate the shortest possible path. This path is shown in the figure using red dots. Moreover, one can see that we have included to the path the \texttt{via} lanes, too. In the following, we describe the employed algorithms to calculate an ordered list of points which a vehicle has to follow in order to reach a predefined destination. Additionally, we discuss our design decisions, as well as some limitations which were recognised during development.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/nav}
	\label{fig:nav}
	\caption{MMK Car, above right and the calculated shortest path (red) to a predefined user destination (down right, blue).}
\end{figure}
\section{Routing Algorithm}
Currently, there exist many algorithms able to calculate the shortest path between two points, \emph{e.g.} Dijkstra, Bellman-Ford, A*. Some of these algorithms work under special conditions, \emph{e.g.} Dijkstra can be applied to graphs where no edge has negative weight. On the other hand Bellman-Ford is more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers. Since in our graph there are only edges with positive weights, we decided to choose Dijkstra for our implementation.

Dijkstra's algorithm is a shortest-path algorithm that iteratively searches from a start node \emph{s} to a target note \emph{t}\cite{skiena1998algorithm}. From a currently visited node \emph{v}, all neighbouring, unvisited nodes get a weight set based on the edge weights. Each node encountered gets a weight \emph{w} assigned which denotes the distance from \emph{s} to this node via the current node \emph{v}. If a node already has a weight, it is only changed if the new weight would be lower, ensuring an optimal solution.
The algorithm forms a circle around the start node, with a radius increasing in each step. The search can be stopped once \emph{t} has been visited. The resulting path is the shortest path from \emph{s} to \emph{t}.

\section{Implementation Details}
First of all, we have to build a graph from the connectivity information in order to apply Dijkstra to it and calculate the shortest path between two points. However, this cannot be done in a straightforward way because in this case the nodes of the graph are the actual lanes and the connections are links between them which have no length. Of course, some connections have "via" lanes which can be used to calculate the distance between two lanes but this cannot be applied everywhere. Moreover, in order a vehicle to drive from the start of a given lane A to the start of another, adjacent to A, lane B, it has to drive through the whole lane A. This intuition helped us to design the actual graph. Since links between lanes do not provide wighting information (apart from the sum of the length of via lanes if they are present), we defined \textbf{the weight of an edge} connecting given lane A and lane B (in the direction from lane A to lane B) as the \textbf{length of lane A}. Since, there is no connectivity information for neighbouring lanes, we do not consider these connections.

After designing the graph, we have to decide its representation in memory. There are many possibilities to achieve this, \emph{e.g.} adjacency matrix, edge list, adjacency array/list. The most crucial part of the Dijkstra algorithm as already explained is the finding of neighbouring nodes, which has to be done in an efficient way. Therefore, we have chosen to utilise an adjacency list to hold the graph information. Additionally, we implemented a special object \texttt{NetworkLaneConnection} (Figure \ref{fig:unity-uml}). In the \texttt{Network} class, using the \texttt{BuildConnectivityGraph(\_:\;JSONNode)} method we parse all connections defined in the semantic road description export file. Firstly, we initialise a data structure to store all \texttt{NetworkLaneConnection} objects. Each object in has, as can be seen in Figure \ref{fig:unity-uml}, a lane object and a list with all adjacent to it other lanes. Next, for every connection between two lanes, we either create a new \texttt{NetworkLaneConnection} using the \texttt{fromLane} and \texttt{toLane} as respectively the \texttt{lane} attribute and the first lane in the adjacentLanes list. Otherwise, the corresponding \texttt{NetworkLaneConnection} object with the current lane already exists and we just have to store the \texttt{toLane} to the list of adjacent lanes. Additionally, we store all \texttt{via} lanes to the corresponding destination lanes.

Next, we implemented Dijkstra in the \texttt{Network} class which calculates the shortest path between two lanes given their id values. Additionally, we used the \texttt{SimplePriorityQueue} class presented in Chapter \ref{ch:background}. The id values of the start and destination lane were calculated using the \texttt{RoadPosition} method detailed in Chapter \ref{ch:descriptionOfRoadSystems}. There are two requirements, which has to be fulfilled in order to start the algorithm. Firstly, the vehicle has to be on a valid lane and secondly, the destination point has to lay again on a valid lane. Using the id values of the start and destination lane, we can invoke the \texttt{CalculateRoute} method in \texttt{Network} class. The result is a list of \texttt{NetworkLanes} which have to be traversed in order a vehicle to reach the desired destination. If there is no route found or some of the aforementioned two requirements is not valid, then the method returns \texttt{null}. Nonetheless, this is not the result we wanted in the beginning because the vehicle awaits from us an ordered list of navigation points which it can follow.\\

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/navpoints}
	\label{fig:navpoints}
	\caption{Given a path of lanes (direction from A via B to C) and the coordinates of the vehicle at the start (green point) and the destination (blue point), we use the \emph{dot} product to calculate which points have to be excluded from the final path.}
\end{figure}

Lastly, we have to collect all points which construct each lane on the calculated shortest path. Generally, there are two cases where different lanes has to be handled separately: (1) the first and the last lane, (2) all lanes between them. Since the vehicle does not necessarily start driving through the given route from the start of the first lane, where it is currently situated, we have to exclude all lane points which are "before" the vehicle. Similarly, all points "after" the destination coordinates has to be discarded from the route. An example is shown in Figure \ref{fig:navpoints}, where the green point represents the vehicle, while the blue point is the destination. There are three lanes (A, B, and C), which starts and ends are represented by bigger red dots, and each point on the every lane is a smaller red dot. As we can see, the vehicle is already after the first three points on the start lane, so they don't have to be included in the navigation route. In order to determine which points has to be excluded from the path, we start in the beginning of the first lane and for each point on it we calculate the \emph{dot} product between the vector built by the current point and the vehicle coordinates and the vector built by the current point and the next point on the lane. If the resulting value is negative, \emph{i.e.} the angle between the two vertices is larger than \texttt{90$^{\circ}$}, then this point is excluded from the list. Analogously, the same operation is performed for the destination coordinates.

To summarise, in this chapter we designed a graph from the lane connectivity information provided by SUMO and implemented a routing algorithm in order to determine the shortest path between a given start and destination. 
